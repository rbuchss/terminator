#!/bin/bash
############################################################
# init helpers
############################################################
# helper to source file if it exists and is not zero in size
function source_if_exists() {
  for arg in $@; do
    if [[ -s $arg ]]; then
      if_debug_echo $arg
      source $arg
    else
      if_debug_echo "WARN NO $arg FOUND"
    fi
  done
}

function initialize_path() {
  if [[ -z $path_initialized ]] && [[ "$#" -eq 1 ]]; then
    if [[ -z $PATH ]]; then
      export PATH=$1
    else
      export PATH=$1:$PATH
    fi
  fi
}

function initialize_cdpath() {
  if [[ -z $path_initialized ]] && [[ "$#" -eq 1 ]]; then
    if [[ -z $CDPATH ]]; then
      export CDPATH=$1
    else
      export CDPATH=$1:$CDPATH
    fi
  fi
}

function initialize_manpath() {
  if [[ -z $path_initialized ]] && [[ "$#" -eq 1 ]]; then
    if [[ -z $MANPATH ]]; then
      export MANPATH=$1
    else
      export MANPATH=$1:$MANPATH
    fi
  fi
}

function add_brew_paths() {
  for arg in $@; do
    if_debug_echo $arg
    initialize_path "`brew --prefix $arg`/libexec/gnubin"
    initialize_manpath "`brew --prefix $arg`/libexec/gnuman"
  done
}

function if_debug_echo() {
  if [[ "$debug_source" == true ]]; then
    echo $@
  fi
}

############################################################
# core functions
############################################################
function containsElement() {
  local e
  for e in "${@:2}"; do
    if [[ "$e" == "$1" ]]; then
      echo 1
      return 0 # bash exit code
      fi
  done
  echo 0
  return 1 # bash exit code
}

# Temporarily add directories to PATH
function add_path() {
  if [ $# -lt 1 ] || [ $# -gt 2 ]; then
    echo "Temporarily add to PATH"
    echo "usage: apath [dir]"
  else
    PATH=$1:$PATH
  fi
}

# Repeat n times command
function repeat() {
  local i max
  max=$1; shift;
  for ((i=1; i <= max ; i++)); do
    eval "$@";
  done
}

function watch_proc() {
  sleepy_time=1
  while true; do
    clear
    eval $*
    sleep $sleepy_time
  done
}

function ask() {
  echo -n "${RED}$@" '[y/n] ' "${RESET}" ; read ans
  case "$ans" in
    y*|Y*) return 0 ;;
    *) return 1 ;;
  esac
}

# get top fifteen most run commands
function bash_stat() {
  cut -f1 -d" " $HOME/.bash_history | sort | uniq -c | sort -nr | head -n 15
}

# ack history
function hack() {
  history | ack $1
}

function coalesce() {
  #TODO add error for all empty
  for arg in $@; do
    if [[ -n "$arg" ]]; then
      echo "$arg"
      break
    fi
  done
}

function comparsions() {
  case $1 in
    'ge'|'greaterThanOrEqual'|'>=')
      echo '>='
      ;;
    'gt'|'greaterThan'|'>')
      echo '>'
      ;;
    'le'|'lessThanOrEqual'|'<=')
      echo '<='
      ;;
    'lt'|'lessThan'|'<')
      echo '<'
      ;;
    'eq'|'equal'|'==')
      echo '=='
      ;;
    *)
      echo "Invalid option"
      exit 1
      ;;
  esac
}

function compare() {
  version=$1
  comparsion=$2
  ref_version=$3
  result=$(awk "BEGIN{ print ($version $comparsion $ref_version); exit }")
  if [[ $result -eq 1 ]]; then
    echo 1
    exit 0 # for bash success
  else
    echo 0
    exit 1 # for bash failure
  fi
}

function join_by { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }

############################################################
# git helpers
############################################################
function git_url_parse() {
  echo $1 | sed -E 's#(git\@|https://)([^/:]+)(:|/)([^/]+)/(.+$)#'\\$2'#g'
}

function hub_or_git() {
  if command -v hub >/dev/null 2>&1; then
    command hub "$@"
  else
    command git "$@"
  fi
}

############################################################
# compressed file helpers
############################################################
# Handy Extract Program
function extract() {
  if [ -f $1 ] ; then
    case $1 in
     *.tar.bz2)   tar xvjf $1   ;;
     *.tar.gz)  tar xvzf $1   ;;
     *.bz2)     bunzip2 $1    ;;
     *.rar)     unrar x $1    ;;
     *.gz)    gunzip $1     ;;
     *.tar)     tar xvf $1    ;;
     *.tbz2)    tar xvjf $1   ;;
     *.tgz)     tar xvzf $1   ;;
     *.zip)     unzip $1    ;;
     *.Z)     uncompress $1   ;;
     *.7z)    7z x $1     ;;
     *)       echo "'$1' cannot be extracted via >extract<" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Creates an archive from given directory
mktar() { tar cvf  "${1%%/}.tar"   "${1%%/}/"; }
mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }
mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }

############################################################
# file helpers
############################################################
# Swap 2 filenames around, if they exist
function swap() {
  local TMPFILE=tmp.$$

  [ $# -ne 2 ] && echo "swap: 2 arguments needed" && return 1
  [ ! -e $1 ] && echo "swap: $1 does not exist" && return 1
  [ ! -e $2 ] && echo "swap: $2 does not exist" && return 1

  mv "$1" $TMPFILE
  mv "$2" "$1"
  mv $TMPFILE "$2"
}

# changes filename to lowercase
function lowercase() {
  for file ; do
    filename=${file##*/}
    case "$filename" in
    */*) dirname==${file%/*} ;;
    *) dirname=.;;
    esac
    nf=$(echo $filename | tr A-Z a-z)
    newname="${dirname}/${nf}"
    if [ "$nf" != "$filename" ]; then
      mv "$file" "$newname"
      echo "lowercase: $file --> $newname"
    else
      echo "lowercase: $file not changed."
    fi
  done
}

# converts spaces in filename to _
function no_spaces() {
  for file ; do
    filename=${file##*/}
    case "$filename" in
    */*) dirname==${file%/*} ;;
    *) dirname=.;;
    esac
    nf=$(echo $filename | sed -E 's/[[:space:]]+/_/g')
    newname="${dirname}/${nf}"
    if [ "$nf" != "$filename" ]; then
      mv "$file" "$newname"
      echo "no_spaces: $file --> $newname"
    else
      echo "no_spaces: $file not changed."
    fi
  done
}

# finds all files and dirs in the pwd that have spaces in their name
# and renames them with all spaces converted to _
function nuke_spaces() {
  ruby -e 'files = Dir["./*"].select { |file| file.match(/ /) }
    files.each do |file|
      newname = file.gsub(/ /, "_")
      puts "nuke_spaces: #{file} --> #{newname}"
      File.rename(file, newname)
    end'
}

# Find a file from pwd with pattern $1 in name and Execute $2 on it
function find_exec() {
  # Check for proper number of command line args.
  EXPECTED_ARGS=2

  if [ $# -ne $EXPECTED_ARGS ]; then
    echo "ERROR: invaild # of args: Usage: fe pattern cmd"
  else
    find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \; ;
  fi
}

function dirsize_big() {
  dir=${1:-.}
  dir=${dir%%+(/)}

  dirsize "$dir" | grep -E '^ *[0-9.]*[MGTPEZY].'
}

function dirsize() {
  dir=${1:-.}
  dir=${dir%%+(/)}
  cache=/tmp/dirsize-list.$$

  du -shx "$dir"/* 2>/dev/null | \
    sort -n > "$cache"
  # Units are K,M,G,T,P,E,Z,Y
  grep -E '^ *[0-9.]*[^KMGTPEZY]\s+' "$cache"
  grep -E '^ *[0-9.]*K' "$cache"
  grep -E '^ *[0-9.]*M' "$cache"
  grep -E '^ *[0-9.]*G' "$cache"
  grep -E '^ *[0-9.]*T' "$cache"
  grep -E '^ *[0-9.]*P' "$cache"
  grep -E '^ *[0-9.]*E' "$cache"
  grep -E '^ *[0-9.]*Z' "$cache"
  grep -E '^ *[0-9.]*Y' "$cache"
  rm -f "$cache"
}

function mkcd() {
  mkdir -p $1 && cd $1
}

############################################################
# host and network helpers
############################################################
# Get IP address
function my_ip() {
  MY_IP=$(/sbin/ifconfig | awk '/inet/ { print $2 } ' | sed -e s/addr://)
}

# Get current host related info
function hi() {
  echo -e "${RED}You are logged on:${RESET}" ; hostname
  echo -e "\n${RED}Additionnal information:${RESET}" ; uname -a
  echo -e "\n${RED}Current date:${RESET} " ; date
  echo -e "\n${RED}Machine stats:${RESET}" ; uptime
  echo -e "\n${RED}Memory stats:${RESET}" ; free
  echo -e "\n${RED}Disk stats:${RESET}" ; df -kh
  my_ip 2>&- ;
  echo -e "\n${RED}Local IP Address:${RESET}" ; echo ${MY_IP:-"Not connected"}
  echo -e "\n${YELLOW}Users logged on:${RESET}" ; w -h
}

# network information
function ni() {
  echo "--------------- Network Information ---------------"
  /sbin/ifconfig
  echo "---------------------------------------------------"
  echo -e "\nOpen connections : "; netstat;
}

############################################################
# math helpers
############################################################
function trans() {
  awk '{
    for (i=1; i<=NF; i++) {
      a[NR,i] = $i
    }
  }
  NF>p { p = NF }
  END {
    for(j=1; j<=p; j++) {
      str=a[1,j]
      for(i=2; i<=NR; i++) {
        str=str" "a[i,j];
      }
      print str
    }
  }' $1
}

function add_col_rows() {
  awk '{total = total + $1} END{print total}' $1
}

############################################################
# misc
############################################################
function q_exit() {
  while true; do
    xit='null'
    echo "${INVIS}"; read -s -t 1 -n 1 xit
    if [ "$xit" == "q" ]; then
      echo "Good-bye?!${RESET}"; sleep 1; clear; echo "${VIS}"
      break
    else
      clear
      echo `${@}`
    fi
  done
}

function clock() {
  night_hours=('22' '23' '00' '01' '02' '03')
  Cnight_hours=('19' '20' '21' '04' '05' '06')
  timet=$(date +"%R" | sed -E 's/(.{2})/\1 /g' | awk /'/ {print $1}')

  if [[ $(containsElement "$timet" "${night_hours[@]}") -eq 1 ]]; then
    echo "${GREEN}${TXTBLD}"
  elif [[ $(containsElement "$timet" "${Cnight_hours[@]}") -eq 1 ]]; then
    echo "${BLUE}${TXTBLD}"
  else
    echo "${YELLOW}${TXTBLD}"
  fi
  echo -ne `date +"%r"`
}

function timer()
{
  seconds=0
  minutes=0
  hours=0
  while true; do
    xit='null'
    echo "${INVIS}"; read -s -t 1 -n 1 xit

    clear
    echo "${RED}"

    echo "==================================="
    echo "========== $(printf '%02d' ${hours}) : $(printf '%02d' ${minutes}) : $(printf '%02d' ${seconds}) ==========="
    echo "==================================="
    seconds=$((seconds + 1))
    if [ "$minutes" -eq "59" ] && [ "$seconds" -eq "60" ]; then hours=$((hours + 1)) && minutes=0  && seconds=0; fi
    if [ "$seconds" -eq "60" ]; then minutes=$((minutes + 1)) && seconds=0; fi
  done
}

# Linux only: Takes a screenshot of your size choice
function shot() {
  import -frame -strip -quality 75 "$HOME/$(date +%s).png"
}

function reverse_endianness() {
  local expected_args=1
  if [ $# -ne $expected_args ]; then
    echo "Error: invalid # of args: expected $expected_args args"
    echo "Usage: ${FUNCNAME[0]} hex-value"
    return 1
  fi

  value="$1"
  index=${#value}

  while [ "$index" -gt 0 ]; do
    index=$((index-2))
    echo -n "${value:$index:2}"
  done

  echo
}

function expand_url() {
  curl -sIL "$1" | grep ^Location:
}

############################################################
# mysql helpers
############################################################
function spl() {
  command mysql -e 'show processlist' | egrep $1
}

function mysql_find_col() {
  EXPECTED_ARGS=2
  if [ $# -ne $EXPECTED_ARGS ]; then
    echo "ERROR invalid # of args"
    echo "Usage: `basename $0` DBs cols"
    return 65
  fi

  echo "mysql_find_col: searching dbs:$1 for $2"
  command mysql -e "SELECT TABLE_SCHEMA, TABLE_NAME, \
    group_concat(COLUMN_NAME) MATCHING_COLUMNS \
    FROM INFORMATION_SCHEMA.COLUMNS \
    WHERE COLUMN_NAME regexp '$2' \
      and TABLE_SCHEMA regexp '$1' \
    group by 1, 2;"
}

# actually show real hostname in prompt
# even if a localhost connection
function mysql() {
  export mysql_args="$@"
  remote_connection=`ruby -e 'p ENV["mysql_args"].match(/\s*-h\s/) ? true : false'`

  if [[ "$remote_connection" == true ]]; then
    export MYSQL_PS1="[mysql] \u@\h:\d> "
  else
    mysql_hostname=`hostname | sed -E 's/\..+$//'`
    export MYSQL_PS1="[mysql] \u@$mysql_hostname:\d> "
  fi

  if command -v grcat >/dev/null 2>&1; then
    command mysql "$@" --pager='grcat conf.sql'
  else
    command mysql "$@"
  fi
}

############################################################
# psql helpers
############################################################
function psql_list_config() {
  psql -qAt -c 'show hba_file' | xargs grep -v -E '^[[:space:]]*#'
}

function psql_edit_config() {
  vi $(psql -qAt  -c 'SHOW config_file')
}

# from https://stackoverflow.com/questions/13573204/psql-could-not-connect-to-server-no-such-file-or-directory-mac-os-x
function psql_clear_pid() {
  less /usr/local/var/log/postgres.log
  if ask "move /usr/local/var/postgres/postmaster.pid?"; then
    sudo mv /usr/local/var/postgres/postmaster.pid ${HOME}/
  fi
}

############################################################
# process helpers
############################################################
function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }

# Kill by process name
function killps() {
  local pid pname sig="-TERM"   # Default signal
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    echo "Usage: killps [-SIGNAL] pattern"
    return;
  fi
  if [ $# = 2 ]; then sig=$1 ; fi
  for pid in $(my_ps| awk '!/awk/ && $0~pat { print $1 }' pat=${!#} ) ; do
    pname=$(my_ps | awk '$1~var { print $5 }' var=$pid )
    if ask "Kill process $pid <$pname> with signal $sig?"
      then kill -9 $pid
    fi
  done
}

############################################################
# ssh helpers
############################################################
function is_ssh_session() {
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] || is_ssh_sudo; then
    # 0 = true
    return 0
  else
    # 1 = false
    return 1
  fi
}

function ppid () { ps -p ${1:-$$} -o ppid=; }
function ppinfo () { ps -p ${1:-$$} -o ppid= -o user= -o comm=; }

function is_ssh_sudo() {
  user=$(logname)
  pp=$(ppinfo $1)
  ppid=$(ppid $1)
  is_ssh=$(ppinfo $1 | grep "$user sshd")
  if [ -n "$is_ssh" ]; then
    export PBSSHSudo="true"
    return 0 # 0 = true
  elif [ $ppid == 0 ]; then
    unset PBSSHSudo
    return 1 # 1 = false
  elif [ -z "$ppid" ]; then
    unset PBSSHSudo
    return 1 # 1 = false
  else
    is_ssh_sudo "$ppid"
  fi
}

############################################################
# style helpers
############################################################
function color_test_old() {
  echo "${BLACK} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${RED} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${GREEN} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${YELLOW} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${BLUE} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${PURPLE} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${CYAN} TEST test ${TXTBLD} TEST test ${RESET}"
  echo "${WHITE} TEST test ${TXTBLD} TEST test ${RESET}"
}

function color_test() {
  for i in {0..255} ; do
    printf "\x1b[38;5;${i}m%11s" "colour${i}"
    if [ $((($i+1)%8)) == 0 ]; then echo ''; fi
  done
}

function highlight_test() {
  printf '\e[0;31mplain\n\e[1;31mbold\n\e[0;91mhighlight\n\e[1;91mbold+highlight\n\e[0m'
}

function color_code() {
  echo $(printf "\x1b[${1}")
}

############################################################
# tmux helpers
############################################################
# window renamer for tmux
function ssh() {
  if [[ -z $TMUX ]]; then
    command ssh $@
  elif [[ ! -z $TMUX ]] && [[ -z $tmux_ssh_rename_enabled ]]; then
    command ssh $@
  else
    local remote=`echo $* | sed 's/\..*$//'`
    local old_name="$(tmux display-message -p '#W')"
    local renamed=0
    # Save the current name
    if [[ $remote != -* ]]; then
      renamed=1
      tmux rename-window $remote
    fi
    command ssh $@
    if [[ $renamed == 1 ]]; then
      tmux rename-window "$old_name"
    fi
  fi
}

function battery_health() {
  HEART='♥'
  #HEART='█'
  num_hearts=20

  if [[ `uname` == 'Linux' ]]; then
    current_charge=$(cat /proc/acpi/battery/BAT1/state | grep 'remaining capacity' | awk '{print $3}')
    total_charge=$(cat /proc/acpi/battery/BAT1/info | grep 'last full capacity' | awk '{print $4}')
  else
    battery_info=`ioreg -rc AppleSmartBattery`
    current_charge=$(echo $battery_info | grep -o '"CurrentCapacity" = [0-9]\+' | awk '{print $3}')
    total_charge=$(echo $battery_info | grep -o '"MaxCapacity" = [0-9]\+' | awk '{print $3}')
  fi

  charged_slots=$(echo "(($current_charge/$total_charge)*$num_hearts)+1" | bc -l | cut -d '.' -f 1)
  if [[ $charged_slots -gt $num_hearts ]]; then
    charged_slots=$num_hearts
  fi

  echo -n '#[fg=colour196]'
  for i in `seq 1 $charged_slots`; do echo -n "$HEART"; done

  if [[ $charged_slots -lt $num_hearts ]]; then
    echo -n '#[fg=white]'
    for i in `seq 1 $(echo "$num_hearts-$charged_slots" | bc)`; do echo -n "$HEART"; done
  fi
}

function man_or_help() {
  # TODO make a better way to check if command exists
  if command -v $1 >/dev/null 2>&1; then
    command man $1 || \
      command $1 help $2 | less -R || \
      command $1 --help | less -R || \
      command $1 -h | less -R || \
      echo "ERROR: help page for $1 command not found" | less
  else
    echo "ERROR: command $1 not found" | less
  fi
}

function tmux() {
  # shellcheck disable=SC2154
  if [[ $# -eq 0 ]] && [[ -z "$tmux_path_initialized" ]]; then
    # shellcheck source=/dev/null
    source "$HOME/.tmux/bin/session-create.sh"
  fi
  command tmux "$@"
}

############################################################
# ruby Helpers
############################################################
function bundle_helper() {
  for gem in $@; do
    echo -n "Searching for $gem in bundle gempath  ...  "
    bundle exec ruby -e "gem = \"$gem\";
    gem_path = Bundler.rubygems.find_name(gem).first.full_gem_path;
    puts \"Gempath for #{gem} ~~~> #{gem_path}\""
  done
}

function rails_diff() {
  colordiff --exclude=.git \
    --exclude=.bundle \
    --exclude=secrets.yml \
    --exclude=log \
    --exclude=pkg \
    --exclude=*.sqlite3* \
    --exclude=sandcube \
    --exclude=tmp \
    --exclude=Gemfile.lock \
    --exclude=.yardoc \
    --exclude=doc \
    --exclude=coverage \
    -ur $1 $2 | less -R
}

############################################################
# Vagrant Helpers
############################################################
function scp_vagrant() {
  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o \
    IdentitiesOnly=yes -o LogLevel=ERROR -i $HOME/.vagrant.d/insecure_private_key -P 2202 \
    $1 vagrant@127.0.0.1:
}

############################################################
# PS1 Helpers
############################################################
function svn_ps1_info() {
  # svn info
  stat .svn > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    SURL=`svn info | grep URL | head -1 | perl -pe 's/URL: (.*)/\1/'`
    if [ `echo $SURL | grep -E "branches|tags"` ]; then
      SVER=`echo $SURL \
        | perl -pe 's{.*/(branches|tags)/(.*)}{\1/\2}' | cut -d/ -f1-2`
      SPTH=`echo $SURL \
        | perl -pe 's{.*svnroot/(.*)/(branches|tags)/.*}{/\1}'`
      SPWD="$SPTH/$SVER"
      SCL=$IGreen
    else
      SPWD=`echo $SURL \
        | perl -pe 's{.*svnroot/(.*)/trunk(.*)}{/\1/trunk}'`
      SCL=$IYellow
    fi
    svn status | egrep '.+' > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      SCL=$IRed
    fi
    export SvnInfoWColor="$SCL[SVN: $SPWD]"
  else
    export SvnInfoWColor=""
  fi
}

function git_ps1_info() {
  # git info
  git branch >/dev/null 2>&1 && command -v __git_ps1 >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    GitBranch=`__git_ps1 "%s"`
    if [[ $GitBranch =~ ^\( ]]; then
      char=$detached_head_char
    else
      char=$branch_char
    fi
    git status | grep "nothing to commit" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      # Clean repository - nothing to commit
      clean_color=$(color_code "38;5;10m")
      export GitInfoWColor="${clean_color}$char $GitBranch $check_char$ColorOff"
    else
      git status | egrep '(Changes to be committed|Changes not staged for commit)' >/dev/null 2>&1
      if [ $? -eq 0 ]; then
        # Changes to working tree
        dirty_color=$(color_code "38;5;9m")
        export GitInfoWColor="${dirty_color}$char $GitBranch $x_char$ColorOff"
      else
        dirty_color=$(color_code "38;5;214m")
        export GitInfoWColor="${dirty_color}$char $GitBranch $x_char$ColorOff"
      fi
    fi
  else
    export GitInfoWColor=""
  fi
}

function ssh_ps1_info() {
  if is_ssh_session; then
    export PBSSHed="${HostColor}${HostChar} "
  else
    export PBSSHed=""
  fi
}

function user_ps1_info() {
  export PBUser="${UserColor}${UserName}"
}

function host_ps1_info() {
  export PBHost="${HostColor}${HostName}"
}

function pwd_ps1_info() {
  export PBPwd="${PathColor}${PathFull}"
}

function basic_ps1_info() {
  user_ps1_info
  host_ps1_info
  pwd_ps1_info
  export PBBasic="${PBUser}${UserSeparator}${PBHost} ${PBPwd}"
}

function vcs_ps1_info() {
  svn_ps1_info
  git_ps1_info
  export PBVcs="${SvnInfoWColor}${GitInfoWColor}"
}

function base_ps1_info() {
  ssh_ps1_info
  basic_ps1_info
  vcs_ps1_info
  export PBBase="${PBSSHed}${PBBasic} ${PBVcs}"
}

# must be run first in full_ps1_info
# flag if last command had non-zero exit status
function error_ps1_info() {
  last_command_exit=$?
  if [ $last_command_exit -eq 0 ]; then
    export PBError=""
  else
    export PBError="${IRed}${x_char} "
  fi
}

function suffix_ps1_info() {
  export PBSuffix="${NewLine}${arrow_char} ${ColorOff}"
}

# Customize BASH PS1 prompt to show current
# GIT or SVN repository and branch
# along with colorization to show status
# (red dirty/green clean)
function full_ps1_info() {
  error_ps1_info
  base_ps1_info
  suffix_ps1_info
  export PS1="${PBError}${PBBase} ${PBSuffix}"
}
